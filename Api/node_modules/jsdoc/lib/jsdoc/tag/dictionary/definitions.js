/**
 * Define tags that are known in JSDoc.
 * @module jsdoc/tag/dictionary/definitions
 */
const _ = require('underscore');
const jsdoc = {
    env: require('jsdoc/env'),
    name: require('jsdoc/name'),
    src: {
        astnode: require('jsdoc/src/astnode')
    },
    tag: {
        inline: require('jsdoc/tag/inline'),
        type: require('jsdoc/tag/type')
    },
    util: {
        doop: require('jsdoc/util/doop'),
        logger: require('jsdoc/util/logger')
    }
};
const path = require('jsdoc/path');
const Syntax = require('jsdoc/src/syntax').Syntax;

const hasOwnProp = Object.prototype.hasOwnProperty;

const DEFINITIONS = {
    closure: 'closureTags',
    jsdoc: 'jsdocTags'
};
const MODULE_NAMESPACE = 'module:';

// Clone a tag definition, excluding synonyms.
function cloneTagDef(tagDef, extras) {
    const newTagDef = jsdoc.util.doop(tagDef);

    delete newTagDef.synonyms;

    return (extras ? _.extend(newTagDef, extras) : newTagDef);
}

function getSourcePaths() {
    const sourcePaths = jsdoc.env.sourceFiles.slice(0) || [];

    if (jsdoc.env.opts._) {
        jsdoc.env.opts._.forEach(sourcePath => {
            const resolved = path.resolve(jsdoc.env.pwd, sourcePath);

            if (!sourcePaths.includes(resolved)) {
                sourcePaths.push(resolved);
            }
        });
    }

    return sourcePaths;
}

function filepathMinusPrefix(filepath) {
    const sourcePaths = getSourcePaths();
    const commonPrefix = path.commonPrefix(sourcePaths);
    let result = '';

    if (filepath) {
        filepath = path.normalize(filepath);
        // always use forward slashes in the result
        result = (filepath + path.sep).replace(commonPrefix, '')
            .replace(/\\/g, '/');
    }

    if (result.length > 0 && result[result.length - 1] !== '/') {
        result += '/';
    }

    return result;
}

/** @private */
function setDocletKindToTitle(doclet, {title}) {
    doclet.addTag( 'kind', title );
}

function setDocletScopeToTitle(doclet, {title}) {
    try {
        doclet.setScope(title);
    }
    catch (e) {
        jsdoc.util.logger.error(e.message);
    }
}

function setDocletNameToValue(doclet, {value, text}) {
    if (value && value.description) { // as in a long tag
        doclet.addTag('name', value.description);
    }
    else if (text) { // or a short tag
        doclet.addTag('name', text);
    }
}

function setDocletNameToValueName(doclet, {value}) {
    if (value && value.name) {
        doclet.addTag('name', value.name);
    }
}

function setDocletDescriptionToValue(doclet, {value}) {
    if (value) {
        doclet.addTag('description', value);
    }
}

function setDocletTypeToValueType(doclet, {value}) {
    if (value && value.type) {
        // Add the type names and other type properties (such as `optional`).
        // Don't overwrite existing properties.
        Object.keys(value).forEach(prop => {
            if ( !hasOwnProp.call(doclet, prop) ) {
                doclet[prop] = value[prop];
            }
        });
    }
}

function setNameToFile(doclet) {
    let name;

    if (doclet.meta.filename) {
        name = filepathMinusPrefix(doclet.meta.path) + doclet.meta.filename;
        doclet.addTag('name', name);
    }
}

function setDocletMemberof(doclet, {value}) {
    if (value && value !== '<global>') {
        doclet.setMemberof(value);
    }
}

function applyNamespace(docletOrNs, tag) {
    if (typeof docletOrNs === 'string') { // ns
        tag.value = jsdoc.name.applyNamespace(tag.value, docletOrNs);
    }
    else { // doclet
        if (!docletOrNs.name) {
            return; // error?
        }

        docletOrNs.longname = jsdoc.name.applyNamespace(docletOrNs.name, tag.title);
    }
}

function setDocletNameToFilename(doclet) {
    let name = '';

    if (doclet.meta.path) {
        name = filepathMinusPrefix(doclet.meta.path);
    }
    name += doclet.meta.filename.replace(/\.js$/i, '');

    doclet.name = name;
}

function parseTypeText(text) {
    const tagType = jsdoc.tag.type.parse(text, false, true);

    return tagType.typeExpression || text;
}

function parseBorrows(doclet, {text}) {
    const m = /^([\s\S]+?)(?:\s+as\s+([\s\S]+))?$/.exec(text);

    if (m) {
        if (m[1] && m[2]) {
            return {
                target: m[1],
                source: m[2]
            };
        }
        else if (m[1]) {
            return {
                target: m[1]
            };
        }

        return {};
    } else {
        return {};
    }
}

function stripModuleNamespace(name) {
    return name.replace(/^module:/, '');
}

function firstWordOf(string) {
    const m = /^(\S+)/.exec(string);

    if (m) {
        return m[1];
    }
    else {
        return '';
    }
}

function combineTypes({value}) {
    let combined;

    if (value && value.type) {
        if (value.type.names.length === 1) {
            combined = value.type.names[0];
        }
        else {
            combined = `(${value.type.names.join('|')})`;
        }
    }

    return combined;
}

// Tags that JSDoc uses internally, and that must always be defined.
const internalTags = {
    // Special separator tag indicating that multiple doclets should be generated for the same
    // comment. Used internally (and by some JSDoc users, although it's not officially supported).
    // In the following example, the parser will replace `//**` with an `@also` tag:
    // /**
    //  * Foo.
    //  *//**
    //  * Foo with a param.
    //  * @param {string} bar
    //  */
    //  function foo(bar) {}
    also: {
        onTagged() {
            // let the parser handle it; we define the tag here to avoid "not a known tag" errors
        }
    },
    description: {
        mustHaveValue: true,
        synonyms: ['desc']
    },
    kind: {
        mustHaveValue: true
    },
    name: {
        mustHaveValue: true
    },
    undocumented: {
        mustNotHaveValue: true,
        onTagged(doclet) {
            doclet.undocumented = true;
            doclet.comment = '';
        }
    }
};

// Core JSDoc tags that are shared with other tag dictionaries.
let baseTags = exports.baseTags = {
    abstract: {
        mustNotHaveValue: true,
        onTagged(doclet) {
            // we call this `virtual` because `abstract` is a reserved word
            doclet.virtual = true;
        },
        synonyms: ['virtual']
    },
    access: {
        mustHaveValue: true,
        onTagged(doclet, {value}) {
            // only valid values are package, private, protected and public
            if ( /^(package|private|protected|public)$/i.test(value) ) {
                doclet.access = value.toLowerCase();
            }
            else {
                delete doclet.access;
            }
        }
    },
    alias: {
        mustHaveValue: true,
        onTagged(doclet, {value}) {
            doclet.alias = value;
        }
    },
    async: {
        mustNotHaveValue: true,
        onTagged(doclet) {
            doclet.async = true;
        }
    },
    augments: {
        mustHaveValue: true,
        // Allow augments value to be specified as a normal type, e.g. {Type}
        onTagText: parseTypeText,
        onTagged(doclet, {value}) {
            doclet.augment( firstWordOf(value) );
        },
        synonyms: ['extends']
    },
    author: {
        mustHaveValue: true,
        onTagged(doclet, {value}) {
            doclet.author = doclet.author || [];
            doclet.author.push(value);
        }
    },
    // this symbol has a member that should use the same docs as another symbol
    borrows: {
        mustHaveValue: true,
        onTagged(doclet, tag) {
            const borrows = parseBorrows(doclet, tag);

            doclet.borrow(borrows.target, borrows.source);
        }
    },
    class: {
        onTagged(doclet, tag) {
            let looksLikeDesc;

            doclet.addTag('kind', 'class');

            // handle special case where both @class and @constructor tags exist in same doclet
            if (tag.originalTitle === 'class') {
                // multiple words after @class?
                looksLikeDesc = (tag.value || '').match(/\S+\s+\S+/);
                if ((looksLikeDesc