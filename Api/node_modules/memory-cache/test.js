/* global describe, it, before, beforeEach, afterEach */
'use strict';

var chai = require('chai'),
    expect = chai.expect,
    sinon = require('sinon'),
    sinonChai = require('sinon-chai'),
    Cache = require('./index').Cache,
    cache = new Cache(),
    clock;

chai.use(sinonChai);


describe('node-cache', function() {
  beforeEach(function() {
    clock = sinon.useFakeTimers();

    cache.clear();
  });

  afterEach(function() {
    clock.restore();
  });

  describe('put()', function() {
    before(function() {
      cache.debug(false);
    });

    it('should allow adding a new item to the cache', function() {
      expect(function() {
        cache.put('key', 'value');
      }).to.not.throw();
    });

    it('should allow adding a new item to the cache with a timeout', function() {
      expect(function() {
        cache.put('key', 'value', 100);
      }).to.not.throw();
    });

    it('should allow adding a new item to the cache with a timeout callback', function() {
      expect(function() {
        cache.put('key', 'value', 100, function() {});
      }).to.not.throw();
    });

    it('should throw an error given a non-numeric timeout', function() {
      expect(function() {
        cache.put('key', 'value', 'foo');
      }).to.throw();
    });

    it('should throw an error given a timeout of NaN', function() {
      expect(function() {
        cache.put('key', 'value', NaN);
      }).to.throw();
    });

    it('should throw an error given a timeout of 0', function() {
      expect(function() {
        cache.put('key', 'value', 0);
      }).to.throw();
    });

    it('should throw an error given a negative timeout', function() {
      expect(function() {
        cache.put('key', 'value', -100);
      }).to.throw();
    });

    it('should throw an error given a non-function timeout callback', function() {
      expect(function() {
        cache.put('key', 'value', 100, 'foo');
      }).to.throw();
    });

    it('should cause the timeout callback to fire once the cache item expires', function() {
      var spy = sinon.spy();
      cache.put('key', 'value', 1000, spy);
      clock.tick(999);
      expect(spy).to.not.have.been.called;
      clock.tick(1);
      expect(spy).to.have.been.calledOnce.and.calledWith('key', 'value');
    });

    it('should override the timeout callback on a new put() with a different timeout callback', function() {
      var spy1 = sinon.spy();
      var spy2 = sinon.spy();
      cache.put('key', 'value', 1000, spy1);
      clock.tick(999);
      cache.put('key', 'value', 1000, spy2)
      clock.tick(1001);
      expect(spy1).to.not.have.been.called;
      expect(spy2).to.have.been.calledOnce.and.calledWith('key', 'value');
    });

    it('should cancel the timeout callback on a new put() without a timeout callback', function() {
      var spy = sinon.spy();
      cache.put('key', 'value', 1000, spy);
      clock.tick(999);
      cache.put('key', 'value');
      clock.tick(1);
      expect(spy).to.not.have.been.called;
    });

    it('should return the cached value', function() {
      expect(cache.put('key', 'value')).to.equal('value');
    });
  });

  describe('del()', function() {
    before(function() {
      cache.debug(false);
    });

    it('should return false given a key for an empty cache', function() {
      expect(cache.del('miss')).to.be.false;
    });

    it('should return false given a key not in a non-empty cache', function() {
      cache.put('key', 'value');
      expect(cache.del('miss')).to.be.false;
    });

    it('should return true given a key in the cache', function() {
      cache.put('key', 'value');
      expect(cache.del('key')).to.be.true;
    });

    it('should remove the provided key from the cache', function() {
      cache.put('key', 'value');
      expect(cache.get('key')).to.equal('value');
      expect(cache.del('key')).to.be.true;
      expect(cache.get('key')).to.be.null;
    });

    it('should decrement the cache size by 1', function() {
      cache.put('key', 'value');
      expect(cache.size()).to.equal(1);
      expect(cache